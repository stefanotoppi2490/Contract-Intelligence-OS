// Contract Intelligence OS — Prisma schema (PostgreSQL)
// STEP 1: Prisma DB Core v1

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ─── Enums ─────────────────────────────────────────────────────────────────

enum MemberRole {
  OWNER
  ADMIN
  LEGAL
  RISK
  MEMBER
  VIEWER
}

enum CounterpartyType {
  CUSTOMER
  VENDOR
}

enum ContractType {
  NDA
  MSA
  SOW
  SLA
  OTHER
}

enum ContractStatus {
  DRAFT
  IN_REVIEW
  SIGNED
  ARCHIVED
}

enum DocumentSource {
  UPLOAD
  INTEGRATION
}

enum IngestionStatus {
  UPLOADED
  TEXT_READY
  ERROR
}

enum TextExtractor {
  PDF
  DOCX
  TXT
}

enum TextStatus {
  TEXT_READY
  ERROR
}

enum ClauseType {
  LIABILITY_CAP
  INDEMNIFICATION
  TERM
  TERMINATION
  DATA_PROCESSING
  IP_ASSIGNMENT
  CONFIDENTIALITY
  GOVERNING_LAW
  OTHER
}

// STEP 5A: clause taxonomy for policy engine
enum ClauseTaxonomy {
  TERMINATION
  LIABILITY
  INTELLECTUAL_PROPERTY
  PAYMENT_TERMS
  DATA_PRIVACY
  CONFIDENTIALITY
  GOVERNING_LAW
  SLA
  SCOPE
  OTHER
}

// STEP 5A: rule types for deterministic policy engine
enum PolicyRuleType {
  REQUIRED
  FORBIDDEN
  MIN_VALUE
  MAX_VALUE
  ALLOWED_VALUES
}

// STEP 5A: per-finding compliance status
enum FindingComplianceStatus {
  COMPLIANT
  VIOLATION
  UNCLEAR
  NOT_APPLICABLE
}

// STEP 5A: aggregate compliance status per version+policy
enum ComplianceStatusType {
  COMPLIANT
  NEEDS_REVIEW
  NON_COMPLIANT
}

enum RuleType {
  THRESHOLD
  BOOLEAN
  WHITELIST
  CONDITIONAL
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum RiskType {
  LEGAL
  FINANCIAL
  OPERATIONAL
  DATA
  SECURITY
}

enum PartyBias {
  FAVOR_US
  NEUTRAL
  FAVOR_COUNTERPARTY
}

enum ComplianceStatus {
  COMPLIANT
  NON_COMPLIANT
  UNPOLICED
  REQUIRES_HUMAN_REVIEW
}

enum RecommendedAction {
  ACCEPT
  NEGOTIATE
  ESCALATE
}

enum ExceptionStatus {
  REQUESTED
  APPROVED
  REJECTED
  WITHDRAWN
}

enum ExceptionDecision {
  APPROVE
  REJECT
}

enum LedgerEventType {
  CONTRACT_UPLOADED
  TEXT_EXTRACTED
  ANALYSIS_RUN
  EXCEPTION_REQUESTED
  EXCEPTION_APPROVED
  EXCEPTION_REJECTED
  EXCEPTION_WITHDRAWN
  POLICY_CREATED
  POLICY_RULE_CREATED
  POLICY_RULE_UPDATED
  POLICY_RULE_DELETED
  VERSION_COMPARED
  REPORT_EXPORTED
}

// ─── Tenant & Auth ─────────────────────────────────────────────────────────

model Workspace {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships        Membership[]
  counterparties     Counterparty[]
  contracts          Contract[]
  policies           Policy[]
  riskLedgerEvents   RiskLedgerEvent[]
  ledgerEvents       LedgerEvent[]
  exceptionRequests  ExceptionRequest[]
  auditEvents        AuditEvent[]

  @@index([createdAt])
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  memberships Membership[]
  accounts    Account[]
  sessions    Session[]
}

// Auth.js Prisma Adapter
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model Membership {
  id          String     @id @default(cuid())
  workspaceId String
  userId      String
  role        MemberRole
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, userId])
  @@index([workspaceId, createdAt])
}

// ─── Business entities ─────────────────────────────────────────────────────

model Counterparty {
  id          String           @id @default(cuid())
  workspaceId String
  name        String
  type        CounterpartyType  @default(CUSTOMER)
  notes       String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  contracts Contract[]

  @@unique([workspaceId, name])
  @@index([workspaceId, createdAt])
}

model Contract {
  id             String         @id @default(cuid())
  workspaceId    String
  counterpartyId String
  title          String
  contractType   ContractType?
  status         ContractStatus @default(DRAFT)
  startDate      DateTime?
  endDate        DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  workspace   Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  counterparty Counterparty   @relation(fields: [counterpartyId], references: [id], onDelete: Restrict)
  versions    ContractVersion[]

  @@index([workspaceId, createdAt])
}

model ContractVersion {
  id             String   @id @default(cuid())
  contractId     String
  versionNumber  Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  contract           Contract             @relation(fields: [contractId], references: [id], onDelete: Cascade)
  documents          Document[]
  versionText        ContractVersionText?
  clauseFindings     ClauseFinding[]
  policyViolations   PolicyViolation[]
  exceptionRequests  ExceptionRequest[]
  contractCompliance ContractCompliance[]

  @@unique([contractId, versionNumber])
  @@index([contractId, createdAt])
}

model Document {
  id                 String           @id @default(cuid())
  contractVersionId  String
  originalName       String
  fileName           String?
  mimeType           String?
  size               Int?
  storageKey         String?
  source             DocumentSource   @default(UPLOAD)
  ingestionStatus    IngestionStatus? @default(UPLOADED)
  lastError          String?          @db.Text
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  contractVersion ContractVersion @relation(fields: [contractVersionId], references: [id], onDelete: Cascade)

  @@index([contractVersionId, createdAt])
}

model ContractVersionText {
  id                 String       @id @default(cuid())
  contractVersionId  String       @unique
  text               String       @db.Text
  extractedAt        DateTime     @default(now())
  extractor          TextExtractor
  status             TextStatus
  errorMessage       String?      @db.Text
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt

  contractVersion ContractVersion @relation(fields: [contractVersionId], references: [id], onDelete: Cascade)

  @@index([contractVersionId])
}

// ─── AI & analysis artifacts (STEP 5A: policy engine findings) ───────────────

model ClauseFinding {
  id                String                 @id @default(cuid())
  contractVersionId String
  clauseType        ClauseTaxonomy
  ruleId            String                 // FK to PolicyRule
  complianceStatus  FindingComplianceStatus
  severity          Severity?
  riskType          RiskType?
  recommendation    String?                @db.Text
  // STEP 5B: AI extraction
  foundText         String?                @db.Text  // excerpt from contract (max ~700 chars)
  foundValue        Json?                  // parsed value
  confidence        Float?                 // 0..1
  parseNotes        String?                @db.Text
  evaluatedAt       DateTime?
  engineVersion     String?                // e.g. "5b-1"
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt

  contractVersion ContractVersion  @relation(fields: [contractVersionId], references: [id], onDelete: Cascade)
  rule            PolicyRule       @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  exceptionRequests ExceptionRequest[]

  @@unique([contractVersionId, ruleId])
  @@index([contractVersionId, createdAt])
}

model Policy {
  id          String   @id @default(cuid())
  workspaceId String
  name        String
  description String?  @db.Text
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  workspace          Workspace           @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  rules              PolicyRule[]
  policyViolations   PolicyViolation[]
  exceptionRequests  ExceptionRequest[]
  contractCompliance ContractCompliance[]

  @@index([workspaceId, createdAt])
}

model PolicyRule {
  id             String         @id @default(cuid())
  policyId       String
  clauseType     ClauseTaxonomy
  ruleType       PolicyRuleType
  expectedValue  Json?          // string | number | json
  severity       Severity?
  riskType       RiskType?
  weight         Int            @default(1) // deducted per VIOLATION
  recommendation String         @db.Text // required; used when creating ClauseFinding for VIOLATION
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  policy         Policy          @relation(fields: [policyId], references: [id], onDelete: Cascade)
  clauseFindings ClauseFinding[]

  @@index([policyId, clauseType])
  @@index([policyId, createdAt])
}

model ContractCompliance {
  id                 String               @id @default(cuid())
  contractVersionId  String
  policyId           String
  score              Int                  // 0–100
  status             ComplianceStatusType
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  contractVersion ContractVersion @relation(fields: [contractVersionId], references: [id], onDelete: Cascade)
  policy          Policy         @relation(fields: [policyId], references: [id], onDelete: Cascade)

  @@unique([contractVersionId, policyId])
  @@index([contractVersionId, createdAt])
}

model PolicyViolation {
  id                String   @id @default(cuid())
  contractVersionId String
  policyId          String   // FK to Policy.id
  foundValue        Json?
  expectedValue     Json?
  severity          Severity?
  evidenceAnchors   Json?
  complianceStatus ComplianceStatus
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  contractVersion ContractVersion @relation(fields: [contractVersionId], references: [id], onDelete: Cascade)
  policy          Policy         @relation(fields: [policyId], references: [id], onDelete: Cascade)

  @@unique([contractVersionId, policyId])
  @@index([contractVersionId, createdAt])
}

// ─── Workflow ──────────────────────────────────────────────────────────────

model ExceptionRequest {
  id                String           @id @default(cuid())
  workspaceId       String
  contractId        String
  contractVersionId String
  clauseFindingId   String?
  policyId          String?
  clauseType        String?          // denormalized for lists
  title             String          @db.Text
  justification     String          @db.Text
  requestedByUserId String
  status            ExceptionStatus
  decidedByUserId   String?
  decidedAt         DateTime?
  decisionReason    String?          @db.Text
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  workspace       Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  contractVersion ContractVersion  @relation(fields: [contractVersionId], references: [id], onDelete: Cascade)
  clauseFinding   ClauseFinding?    @relation(fields: [clauseFindingId], references: [id], onDelete: SetNull)
  policy          Policy?          @relation(fields: [policyId], references: [id], onDelete: SetNull)
  comments        ExceptionComment[]

  @@index([workspaceId, status])
  @@index([contractVersionId, policyId])
  @@index([contractVersionId, createdAt])
  @@index([clauseFindingId])
}

model ExceptionComment {
  id          String   @id @default(cuid())
  exceptionId String
  userId      String
  message     String   @db.Text
  createdAt   DateTime @default(now())

  exceptionRequest ExceptionRequest @relation(fields: [exceptionId], references: [id], onDelete: Cascade)

  @@index([exceptionId])
}

model LedgerEvent {
  id                 String          @id @default(cuid())
  workspaceId        String
  actorUserId        String?
  type               LedgerEventType
  entityType         String
  entityId           String
  contractId         String?
  contractVersionId  String?
  policyId           String?
  exceptionId        String?
  metadata           Json?
  createdAt          DateTime        @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, createdAt])
  @@index([workspaceId, type])
}

// ─── Append-only logs (immutable; no update flows) ─────────────────────────

model RiskLedgerEvent {
  id          String   @id @default(cuid())
  workspaceId String
  eventType   String
  actorUserId String?
  payload     Json
  createdAt   DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, createdAt])
}

model AuditEvent {
  id          String   @id @default(cuid())
  workspaceId String
  eventType   String
  actorUserId String?
  payload     Json
  createdAt   DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, createdAt])
}
